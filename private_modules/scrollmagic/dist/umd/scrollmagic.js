/*!
 * ScrollMagic v3.0.0-alpha
 * Author: Jan Paepke (https://janpaepke.de)
 * Contributors: Stefan Knop
 * Generated: 2021-04-26
 * License: (MIT OR GPL-3.0+)
 * Docs & Demos: https://scrollmagic.io
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ScrollMagic=t()}(this,(function(){"use strict";const e=e=>"number"==typeof e,t=e=>"string"==typeof e,s=e=>void 0===e,i=e=>null===e,n=e=>e instanceof Window,r=e=>e instanceof HTMLElement,o=e=>e instanceof SVGElement;class c{constructor(){this.callbacks=new Map}addEventListener(e,t){let i=this.callbacks.get(e);return s(i)&&(i=[],this.callbacks.set(e,i)),i.push(t),()=>this.removeEventListener(e,t)}removeEventListener(e,t){const i=this.callbacks.get(e);if(s(i))return;const n=i.filter((e=>e!==t));this.callbacks.set(e,n)}dispatchEvent(e){const t=this.callbacks.get(e.type);s(t)||t.forEach((t=>t(e)))}}const a=(e,t)=>{let s=0;const i=function(...i){clearTimeout(s),s=window.setTimeout((()=>{s=0,e.apply(this,i)}),t)};return i.cancel=function(){clearTimeout(s),s=0},i},l=e=>{const t=n(e)?document.documentElement:e,{clientWidth:s,scrollHeight:i,scrollWidth:r}=t;let{clientHeight:o}=t;if(n(e)){const{innerHeight:t}=e;t-15>o&&(o=t)}return{clientWidth:s,clientHeight:o,scrollHeight:i,scrollWidth:r}},h=e=>n(e)?window.pageYOffset:e.scrollTop,d=e=>n(e)?window.pageXOffset:e.scrollLeft,u=e=>({left:d(e),top:h(e)}),g=(e,t,s,i)=>(e.addEventListener(t,s,i),e.removeEventListener.bind(e,t,s,i)),b=e=>{let t=0;const s=function(...s){0===t&&(t=requestAnimationFrame((()=>{t=0,e.apply(this,s)})))};return s.cancel=()=>{cancelAnimationFrame(t),t=0},s};class p{constructor(e,t,s={deltaX:0,deltaY:0}){this.target=e,this.type=t,this.scrollDelta=s}}const v="scroll",f="resize";class m{constructor(e){this.scrollParent=e,this.dimensions={clientWidth:0,clientHeight:0,scrollWidth:0,scrollHeight:0},this.scrollPos={top:0,left:0},this.dispatcher=new c,this.cleanups=[];const t=b(this.updateScrollPos.bind(this)),s=a(this.updateDimensions.bind(this),100);this.cleanups.push(t.cancel,s.cancel,this.subscribeScroll(t),this.subscribeResize(s)),this.updateScrollPos(),this.updateDimensions()}updateScrollPos(){const e=this.scrollPos;this.scrollPos=u(this.scrollParent);const t=this.scrollPos.top-e.top,s=this.scrollPos.left-e.left;this.dispatcher.dispatchEvent(new p(this,v,{deltaX:s,deltaY:t}))}updateDimensions(){this.dimensions=l(this.scrollParent),this.dispatcher.dispatchEvent(new p(this,f))}subscribeResize(e){const{scrollParent:t}=this;if(n(t))return g(t,f,e);const s=new ResizeObserver(e);return s.observe(t),()=>s.unobserve(t)}subscribeScroll(e){return g(this.scrollParent,v,e)}subscribe(e,t){return this.dispatcher.addEventListener(e,t)}get size(){return this.dimensions}destroy(){this.cleanups.forEach((e=>e())),this.cleanups=[]}}const E="ScrollMagic";class S extends Error{constructor(e){super(e),this.name=E+"Error"}}class O extends S{constructor(e){super("Internal Error: "+e)}}const w=e=>new S(e),P=e=>new O(e),z=(e,...t)=>{null==console||console.warn(`${E} Warning: ${e}`,...t)};class C{constructor(e){this.scene=e,this.unsubscribers=[]}attach(e,t){s(this.container)||this.detach();let i=C.cache.get(e);s(i)&&(i=[new m(e),new Set],C.cache.set(e,i));const[n,r]=i;r.add(this.scene),this.container=n,this.unsubscribers=[n.subscribe("resize",t),n.subscribe("scroll",t)]}detach(){if(s(this.container))return;const{scrollParent:e}=this.container,t=C.cache.get(e);if(s(t))throw P("No cache info for scrollParent");const[i,n]=t;n.delete(this.scene),this.unsubscribers.forEach((e=>e())),this.unsubscribers=[],0===n.size&&(i.destroy(),C.cache.delete(e)),this.container=void 0}get rect(){if(s(this.container))throw P("Can't get size when not attached to a container");return this.container.size}}C.cache=new Map;class y{constructor(e,t){this.execute=e,this.onSchedule=t,this.conditions=[]}schedule(e){s(e)&&(this.conditions=[],e=()=>!0),this.conditions.push(e),this.onSchedule()}resetConditions(){this.conditions=[]}get conditionsMet(){return this.conditions.some((e=>e()))}}class j{constructor(e){this.executeThrottled=b(this.execute.bind(this)),this.commands=Object.entries(e).reduce(((e,[t,s])=>Object.assign(Object.assign({},e),{[t]:new y(s,this.executeThrottled)})),{})}execute(){Object.values(this.commands).forEach((e=>{e.conditionsMet&&e.execute(),e.resetConditions()}))}cancel(){this.executeThrottled.cancel()}}const B={element:null,scrollParent:window,vertical:!0,triggerStart:null,triggerEnd:null,elementStart:0,elementEnd:0},k={default:e=>e,fallback:()=>0},x={start:"top",end:"bottom",size:"height",clientSize:"clientHeight",scrollSize:"scrollHeight",scrollDelta:"deltaY"},L={start:"left",end:"right",size:"width",clientSize:"clientWidth",scrollSize:"scrollWidth",scrollDelta:"deltaX"},M=e=>e?x:L,T=(e,t)=>Object.entries(M(e)).reduce(((e,[s,i])=>Object.assign(Object.assign({},e),{[s]:t[i]})),{}),I=(e,t,s=((e,t,s)=>`Invalid value ${e} for ${t}. ${s}`))=>Object.keys(e).reduce(((i,n)=>{var r;const o=n,c=e[o],a=t[o];let l;try{l=null!==(r=null==a?void 0:a(c))&&void 0!==r?r:c}catch(e){throw w(s(c,o,e.message))}return i[o]=l,i}),{}),D="center",H=e=>100*e+"%",R=([e,t])=>"px"===t?()=>e:t=>e/100*t,W=s=>{if(e(s))return()=>s;if(t(s)){if(D===s){return R([50,"%"])}return(e=>{const t=e.match(/^([+-])?(\d+|\d*[.]\d+)(%|px)$/);if(i(t))throw w("String value must be number with unit, i.e. 20px or 80% or 'center' (=50%)");const[,s,n,r]=t;return R([parseFloat(`${null!=s?s:""}${n}`),r])})(s)}let n;try{n=e(s(1))}catch(e){throw w("Unsupported value type")}if(!n)throw w("Function must return a number");return s},F=e=>{const s=t(e)?(e=>{const t=document.querySelector(e);if(i(t))throw w("No element found for selector "+e);return t})(e):e,{body:n}=window.document;if(!r(s)&&!o(s)||!n.contains(s))throw w("Invalid element supplied");return s},$=e=>t=>i(t)?t:e(t),V=(e,t)=>i(e)||s(e)?t():e,U={element:$(F),scrollParent:e=>{if(n(e)||e instanceof Document)return window;const t=F(e);if(o(t))throw w("Can't use SVG as scrollParent");return t},vertical:e=>!!e,triggerStart:$(W),triggerEnd:$(W),elementStart:W,elementEnd:W},X=e=>((e,t,s=(e=>{z(`Unknown property ${e} will be disregarded`)}))=>Object.entries(e).reduce(((e,[i,n])=>i in t==0?(null==s||s(i),e):(e[i]=n,e)),{}))(e,B),Y=(e,t)=>{const s=X(e),c=I(s,U);const a=(e=>{const{scrollParent:t,element:s}=e,c=e=>V(e,(()=>i(s)?k.fallback:k.default));return I(e,{element:e=>V(e,(()=>{const e=n(t)?document.body:t.firstElementChild;if(i(e)||!r(e)&&!o(e))throw w("Could not autodetect element, as scrollParent has no valid children.");return e})),triggerStart:c,triggerEnd:c})})(Object.assign(Object.assign({},t),c));return(e=>{const{triggerStart:t,triggerEnd:s,elementStart:i,elementEnd:n,vertical:r,scrollParent:o}=e,{size:c}=Q(e),{clientSize:a}=T(r,l(o));c-i(c)-n(c)-(a-t(a)-s(a))<0&&z("Detected no overlap with the configured track options. This means ScrollMagic will not trigger unless this changes later on (i.e. due to resizes).",Object.assign(Object.assign({},e),{triggerStart:t(c),triggerEnd:s(c),elementStart:i(c),elementEnd:n(c)}))})(a),{sanitized:s,processed:a}},Q=({vertical:e,element:t})=>T(e,t.getBoundingClientRect());var q,A,G;!function(e){e.Enter="enter",e.Leave="leave",e.Progress="progress"}(q||(q={})),function(e){e.Start="start",e.Inside="inside",e.End="end"}(A||(A={})),function(e){e.Forward="forward",e.Reverse="reverse"}(G||(G={}));class N{constructor(e,t,s){this.target=e,this.type=t,this.location=q.Progress===t?A.Inside:q.Enter===t&&s||q.Leave===t&&!s?A.Start:A.End,this.direction=s?G.Forward:G.Reverse}}const J=(e,[t,s])=>Object.assign(Object.assign({},e),{[t]:s}),K=(e,t)=>Object.entries(e).filter((([e,s])=>s!==t[e])).reduce(J,{}),Z=(e,t)=>parseFloat(e.toFixed(t)),_=({top:e,right:t,bottom:s,left:i})=>[e,t,s,i].join(" "),ee="0px";class te{constructor(e,t){this.callback=e,this.options={root:null,margin:{top:ee,right:ee,bottom:ee,left:ee}},this.observedElements=new Map,s(t)||(this.options=Object.assign(Object.assign({},this.options),t))}observerCallback(e,t){e.forEach((({target:e,isIntersecting:i})=>{var n;let[r,o]=null!==(n=this.observedElements.get(e))&&void 0!==n?n:[];const c=r&&o;t===this.observerEnter?r=i:o=i,this.observedElements.set(e,[r,o]);const a=r&&o;s(a)||c===a||this.callback(a,e)}))}createObserver(e){const t=this.options.root,s=new IntersectionObserver(this.observerCallback.bind(this),{root:t,rootMargin:e});return[...this.observedElements.keys()].forEach((e=>s.observe(e))),s}rebuildObserver(){var e,t;null===(e=this.observerEnter)||void 0===e||e.disconnect(),null===(t=this.observerLeave)||void 0===t||t.disconnect();const{margin:s}=this.options,i=e=>Math.max(0,parseFloat(e))+"%",n=Object.assign(Object.assign({},s),{top:i(s.top)}),r=Object.assign(Object.assign({},s),{bottom:i(s.bottom)});this.observerEnter=this.createObserver(_(n)),this.observerLeave=this.createObserver(_(r))}optionsChanged({root:e,margin:t}){return!s(e)&&e!==this.options.root||!s(t)&&Object.keys(K(t,this.options.margin)).length>0}modify(e){return this.optionsChanged(e)?(this.options=Object.assign(Object.assign({},this.options),e),this.rebuildObserver(),this):this}observe(e){var t,s;return this.observedElements.has(e)||(this.observedElements.set(e,[void 0,void 0]),null===(t=this.observerEnter)||void 0===t||t.observe(e),null===(s=this.observerLeave)||void 0===s||s.observe(e)),this}unobserve(e){var t,s;return this.observedElements.has(e)&&(this.observedElements.delete(e),null===(t=this.observerEnter)||void 0===t||t.unobserve(e),null===(s=this.observerLeave)||void 0===s||s.unobserve(e)),this}disconnect(){var e,t;this.observedElements.clear(),null===(e=this.observerEnter)||void 0===e||e.disconnect(),null===(t=this.observerLeave)||void 0===t||t.disconnect()}}class se{constructor(e={}){this.name="ScrollMagic",this.dispatcher=new c,this.container=new C(this),this.resizeObserver=new ResizeObserver(b(this.onElementResize.bind(this))),this.viewportObserver=new te(this.onIntersectionChange.bind(this)),this.executionQueue=new j({elementBounds:this.updateElementBoundsCache.bind(this),containerBounds:this.updateContainerBoundsCache.bind(this),viewportObserver:this.updateViewportObserver.bind(this),progress:this.updateProgress.bind(this)}),this.update=this.executionQueue.commands,this.elementBoundsCache={start:0,size:0,offsetStart:0,offsetEnd:0,trackSize:0},this.containerBoundsCache={clientSize:0,offsetStart:0,offsetEnd:0,trackSize:0,scrollSize:0},this.currentProgress=0;const t=Object.assign(Object.assign({},se.defaultOptionsPublic),e);this.modify(t)}getViewportMargin(){const{vertical:e}=this.optionsPrivate,{start:t,end:s}=M(e),{start:i,end:n}=M(!e),{scrollSize:r,clientSize:o}=T(!e,this.container.rect),{clientSize:c,offsetStart:a,offsetEnd:l}=this.containerBoundsCache,{offsetStart:h,offsetEnd:d}=this.elementBoundsCache,u=c-l+d,g=c<=0,b=g?0:-Z((c-a+h)/c,5),p=g?0:-Z(u/c,5),v=o<=0?0:H((r-o)/o);return{[s]:H(b),[t]:H(p),[i]:v,[n]:v}}getTrackSize(){return this.elementBoundsCache.trackSize+this.containerBoundsCache.trackSize}updateIntersectingState(e){this.intersecting=e}updateElementBoundsCache(){const{elementStart:e,elementEnd:t,element:s,vertical:i}=this.optionsPrivate,{start:n,size:r}=T(i,s.getBoundingClientRect()),o=e(r),c=t(r);this.elementBoundsCache={start:n,size:r,offsetStart:o,offsetEnd:c,trackSize:r-o-c}}updateContainerBoundsCache(){const{triggerStart:e,triggerEnd:t,vertical:s}=this.optionsPrivate,{clientSize:i,scrollSize:n}=T(s,this.container.rect),r=e(i),o=t(i);this.containerBoundsCache={clientSize:i,scrollSize:n,offsetStart:r,offsetEnd:o,trackSize:-(i-r-o)}}updateProgress(){const{offsetStart:e,start:t}=this.elementBoundsCache,{offsetStart:s}=this.containerBoundsCache,i=s-(t+e),n=this.getTrackSize();if(n<0)return;const r=this.currentProgress,o=Math.min(Math.max(i/n,0),1),c=o-r;if(0===c)return;this.currentProgress=o;const a=c>0;0!==r&&1!==r||this.triggerEvent(q.Enter,a),this.triggerEvent(q.Progress,a),0!==o&&1!==o||this.triggerEvent(q.Leave,a)}updateViewportObserver(){const{scrollParent:e}=this.optionsPrivate,t={margin:this.getViewportMargin(),root:n(e)?null:e};this.viewportObserver.modify(t)}onOptionChanges(e){const t=e.includes.bind(e),s=t("elementStart"),i=t("elementEnd"),n=t("element"),r=t("scrollParent");if((s||i||n)&&(this.update.elementBounds.schedule(),n)){this.updateIntersectingState(void 0);const{element:e}=this.optionsPrivate;this.viewportObserver.disconnect(),this.viewportObserver.observe(e),this.resizeObserver.disconnect(),this.resizeObserver.observe(e)}r&&(this.update.containerBounds.schedule(),this.updateIntersectingState(void 0),this.container.attach(this.optionsPrivate.scrollParent,this.onContainerUpdate.bind(this))),this.update.viewportObserver.schedule()}onElementResize(){const{update:e,elementBoundsCache:t}=this,{offsetStart:s,offsetEnd:i}=t,n=()=>s!==t.offsetStart||i!==t.offsetEnd;e.elementBounds.schedule(),e.viewportObserver.schedule(n),this.intersecting&&e.progress.schedule(n)}onContainerUpdate(e){const{update:t}=this;if("resize"===e.type){this.update.containerBounds.schedule(),this.intersecting&&t.elementBounds.schedule(),t.viewportObserver.schedule();const{start:e}=this.elementBoundsCache,s=()=>e!==this.elementBoundsCache.start;return void t.progress.schedule(s)}const{scrollDelta:s}=T(this.optionsPrivate.vertical,e.scrollDelta);if(0===s)return;const i=Math.abs(s)>this.getTrackSize();(this.intersecting||i)&&(t.elementBounds.schedule(),t.progress.schedule())}onIntersectionChange(e,t){t===this.optionsPrivate.element&&(this.updateIntersectingState(e),this.update.progress.schedule())}triggerEvent(e,t){this.dispatcher.dispatchEvent(new N(this,e,t))}modify(e){const{sanitized:t,processed:i}=Y(e,this.optionsPrivate);this.optionsPublic=Object.assign(Object.assign({},this.optionsPublic),t);const n=s(this.optionsPrivate)?i:K(i,this.optionsPrivate),r=Object.keys(n);return 0===r.length||(this.optionsPrivate=i,this.onOptionChanges(r)),this}set element(e){this.modify({element:e})}get element(){return this.optionsPublic.element}set scrollParent(e){this.modify({scrollParent:e})}get scrollParent(){return this.optionsPublic.scrollParent}set vertical(e){this.modify({vertical:e})}get vertical(){return this.optionsPublic.vertical}set triggerStart(e){this.modify({triggerStart:e})}get triggerStart(){return this.optionsPublic.triggerStart}set triggerEnd(e){this.modify({triggerEnd:e})}get triggerEnd(){return this.optionsPublic.triggerEnd}set elementStart(e){this.modify({elementStart:e})}get elementStart(){return this.optionsPublic.elementStart}set elementEnd(e){this.modify({elementEnd:e})}get elementEnd(){return this.optionsPublic.elementEnd}get progress(){return this.currentProgress}get scrollOffset(){this.updateElementBoundsCache();const{scrollParent:e,vertical:t}=this.optionsPrivate,{start:s,offsetStart:i,trackSize:n}=this.elementBoundsCache,{clientSize:r,offsetStart:o,offsetEnd:c}=this.containerBoundsCache,{start:a}=T(t,u(e)),l=s+a+i,h=l+n;return{start:Math.floor(l-o),end:Math.ceil(h-r+c)}}get computedOptions(){const{offsetStart:e,offsetEnd:t}=this.containerBoundsCache,{offsetStart:s,offsetEnd:i}=this.elementBoundsCache;return Object.assign(Object.assign({},this.optionsPrivate),{triggerStart:e,triggerEnd:t,elementStart:s,elementEnd:i})}on(e,t){return this.dispatcher.addEventListener(e,t),this}off(e,t){return this.dispatcher.removeEventListener(e,t),this}subscribe(e,t){return this.dispatcher.addEventListener(e,t)}destroy(){this.executionQueue.cancel(),this.resizeObserver.disconnect(),this.viewportObserver.disconnect(),this.container.detach()}static defaultOptions(e={}){return this.defaultOptionsPublic=Object.assign(Object.assign({},this.defaultOptionsPublic),X(e)),this.defaultOptionsPublic}}return se.defaultOptionsPublic=B,se}));
//# sourceMappingURL=scrollmagic.js.map
