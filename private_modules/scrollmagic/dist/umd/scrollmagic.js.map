{"version":3,"file":"scrollmagic.js","sources":["../../src/scrollmagic/util/typeguards.ts","../../src/scrollmagic/ScrollMagicEvent.ts","../../src/scrollmagic/EventDispatcher.ts","../../src/scrollmagic/util/getDimensions.ts","../../src/scrollmagic/util/registerEvent.ts","../../src/scrollmagic/util/throttleRaf.ts","../../src/scrollmagic/Container.ts","../../src/scrollmagic/util/debounce.ts","../../src/scrollmagic/ScrollMagicError.ts","../../src/scrollmagic/ContainerProxy.ts","../../src/scrollmagic/ExecutionQueue.ts","../../src/scrollmagic/Options.ts","../../src/scrollmagic/util/pickRelevantInfo.ts","../../src/scrollmagic/util/processProperties.ts","../../src/scrollmagic/util/transformers.ts","../../src/scrollmagic/Options.processors.ts","../../src/scrollmagic/util/sanitizeProperties.ts","../../src/scrollmagic/util/getScrollPos.ts","../../src/scrollmagic/util/pickDifferencesFlat.ts","../../src/scrollmagic/util/roundToDecimals.ts","../../src/scrollmagic/ViewportObserver.ts","../../src/scrollmagic/ScrollMagic.ts"],"sourcesContent":["export const isNumber = (val: unknown): val is number => typeof val === 'number';\nexport const isString = (val: unknown): val is string => typeof val === 'string';\nexport const isUndefined = (val: unknown): val is undefined => undefined === val;\nexport const isNull = (val: unknown): val is null => null === val;\nexport const isWindow = (val: unknown): val is Window => val instanceof Window;\nexport const isDocument = (val: unknown): val is Document => val instanceof Document;\nexport const isHTMLElement = (val: unknown): val is HTMLElement => val instanceof HTMLElement;\nexport const isSVGElement = (val: unknown): val is SVGElement => val instanceof SVGElement;\n","import { DispatchableEvent } from './EventDispatcher';\nimport { ScrollMagic } from './ScrollMagic';\n\nexport enum ScrollMagicEventType {\n\tEnter = 'enter',\n\tLeave = 'leave',\n\tProgress = 'progress',\n}\n\nexport enum ScrollMagicEventScrollDirection {\n\tForward = 'forward',\n\tReverse = 'reverse',\n}\n\nexport enum ScrollMagicEventLocation {\n\tStart = 'start',\n\tInside = 'inside',\n\tEnd = 'end',\n}\n\nclass ScrollMagicEvent implements DispatchableEvent {\n\tpublic readonly direction: ScrollMagicEventScrollDirection;\n\tpublic readonly location: ScrollMagicEventLocation;\n\tconstructor(\n\t\tpublic readonly type: ScrollMagicEventType,\n\t\tmovingForward: boolean,\n\t\tpublic readonly target: ScrollMagic\n\t) {\n\t\tthis.location = (() => {\n\t\t\tif (ScrollMagicEventType.Progress === type) {\n\t\t\t\treturn ScrollMagicEventLocation.Inside;\n\t\t\t}\n\t\t\tif (\n\t\t\t\t(ScrollMagicEventType.Enter === type && movingForward) ||\n\t\t\t\t(ScrollMagicEventType.Leave === type && !movingForward)\n\t\t\t) {\n\t\t\t\treturn ScrollMagicEventLocation.Start;\n\t\t\t}\n\t\t\treturn ScrollMagicEventLocation.End;\n\t\t})();\n\t\tthis.direction = movingForward\n\t\t\t? ScrollMagicEventScrollDirection.Forward\n\t\t\t: ScrollMagicEventScrollDirection.Reverse;\n\t}\n}\nexport default ScrollMagicEvent;\n","import { isUndefined } from './util/typeguards';\n\ntype EventType = string;\nexport interface DispatchableEvent {\n\treadonly type: EventType;\n\treadonly target: any;\n}\n\ntype Callback<E extends DispatchableEvent> = (event: E) => void;\nexport default class EventDispatcher {\n\tprivate callbacks = new Map<string, Callback<any>[]>();\n\n\t// adds a listener to the dispatcher. returns a function to reverse the effect.\n\tpublic addEventListener<T extends DispatchableEvent>(type: T['type'], cb: Callback<T>): () => void {\n\t\tlet list = this.callbacks.get(type);\n\t\tif (isUndefined(list)) {\n\t\t\tlist = [];\n\t\t\tthis.callbacks.set(type, list);\n\t\t}\n\t\tlist.push(cb);\n\t\treturn () => this.removeEventListener(type, cb);\n\t}\n\n\t// removes a listner from the dispatcher\n\tpublic removeEventListener<T extends DispatchableEvent>(type: T['type'], cb: Callback<T>): void {\n\t\tconst list = this.callbacks.get(type);\n\t\tif (isUndefined(list)) {\n\t\t\treturn;\n\t\t}\n\t\tconst remaining = list.filter(registeredCallback => registeredCallback !== cb);\n\t\tthis.callbacks.set(type, remaining);\n\t}\n\n\t// dispatches an event... DUH!\n\tpublic dispatchEvent(event: DispatchableEvent): void {\n\t\tconst list = this.callbacks.get(event.type);\n\t\tif (isUndefined(list)) {\n\t\t\treturn;\n\t\t}\n\t\tlist.forEach(cb => cb(event));\n\t}\n}\n","import { isWindow } from './typeguards';\n\n// info limited to what we need...\nconst getDimensions = (\n\telement: Window | Element\n): { clientWidth: number; clientHeight: number; scrollWidth: number; scrollHeight: number } => {\n\tconst elem = isWindow(element) ? document.documentElement : element;\n\tconst { clientWidth, clientHeight, scrollHeight, scrollWidth } = elem;\n\treturn {\n\t\tclientWidth,\n\t\tclientHeight,\n\t\tscrollHeight,\n\t\tscrollWidth,\n\t};\n};\n\nexport default getDimensions;\n","/**\n * Adds the passed listener as an event listener to the passed event target, and returns a function which reverses the\n * effect of this function.\n * @param {*} target object the listener should be attached to\n * @param {*} type type of listener\n * @param {*} listener callback\n * @param {*} options Event listener options\n */\nconst registerEvent = (\n\ttarget: GlobalEventHandlers,\n\ttype: keyof (GlobalEventHandlersEventMap & WindowEventMap), // this does not catch if the wrong event is used on the wrong target, but should be stricter than 'string'\n\tlistener: EventListenerOrEventListenerObject,\n\toptions?: boolean | AddEventListenerOptions\n): (() => void) => {\n\ttarget.addEventListener(type, listener, options);\n\treturn target.removeEventListener.bind(target, type, listener, options);\n};\n\nexport default registerEvent;\n","const throttleRaf = <F extends (...a: any) => any>(\n\tfunc: F\n): ((this: ThisParameterType<F>, ...args: Parameters<F>) => void) & {\n\tcancel: () => void;\n} => {\n\tlet requestId = 0; // rAF returns non-zero values, so 0 represents no request pending\n\n\tconst scheduled = function (this: ThisParameterType<F>, ...args: Parameters<F>) {\n\t\tif (0 !== requestId) {\n\t\t\treturn;\n\t\t}\n\t\trequestId = requestAnimationFrame(() => {\n\t\t\trequestId = 0;\n\t\t\tfunc.apply(this, args);\n\t\t});\n\t};\n\n\tscheduled.cancel = () => {\n\t\tcancelAnimationFrame(requestId);\n\t\trequestId = 0;\n\t};\n\treturn scheduled;\n};\n\nexport default throttleRaf;\n","import EventDispatcher, { DispatchableEvent } from './EventDispatcher';\nimport debounce from './util/debounce';\nimport getDimensions from './util/getDimensions';\nimport registerEvent from './util/registerEvent';\nimport throttleRaf from './util/throttleRaf';\nimport { isWindow } from './util/typeguards';\n\nexport type ScrollParent = HTMLElement | Window;\n\ntype CleanUpFunction = () => void;\n\ntype EventType = 'scroll' | 'resize';\nexport class ContainerEvent implements DispatchableEvent {\n\tconstructor(public readonly type: EventType, public readonly target: Container) {}\n}\n\nconst scroll = 'scroll';\nconst resize = 'resize';\n\nexport class Container {\n\tprivate dimensions = {\n\t\t// inner size excluding scrollbars\n\t\tclientWidth: 0,\n\t\tclientHeight: 0,\n\t\t// size of scrollable content\n\t\tscrollWidth: 0,\n\t\tscrollHeight: 0,\n\t};\n\tprivate dispatcher = new EventDispatcher();\n\tprivate cleanups = new Array<CleanUpFunction>();\n\n\tconstructor(public readonly scrollParent: ScrollParent) {\n\t\tconst throttledScroll = throttleRaf(this.updateScrollPos.bind(this));\n\t\tconst throttledResize = debounce(this.updateDimensions.bind(this), 100);\n\t\tthis.cleanups.push(\n\t\t\tthrottledScroll.cancel,\n\t\t\tthrottledResize.cancel,\n\t\t\tthis.subscribeScroll(throttledScroll),\n\t\t\tthis.subscribeResize(throttledResize)\n\t\t);\n\t\tthis.updateScrollPos();\n\t\tthis.updateDimensions();\n\t}\n\n\tprivate updateScrollPos() {\n\t\tthis.dispatcher.dispatchEvent(new ContainerEvent(scroll, this));\n\t}\n\tprivate updateDimensions() {\n\t\tthis.dimensions = getDimensions(this.scrollParent);\n\t\tthis.dispatcher.dispatchEvent(new ContainerEvent(resize, this));\n\t}\n\n\t// subscribes to resize events of scrollParent and returns a function to reverse the effect\n\tprivate subscribeResize(onResize: () => void) {\n\t\tconst { scrollParent } = this;\n\t\tif (isWindow(scrollParent)) {\n\t\t\treturn registerEvent(scrollParent, resize, onResize);\n\t\t}\n\t\tconst observer = new ResizeObserver(onResize);\n\t\tobserver.observe(scrollParent);\n\t\treturn () => observer.unobserve(scrollParent);\n\t}\n\n\t// subscribes to scroll events of scrollParent and returns a function to reverse the effect\n\tprivate subscribeScroll(onScroll: () => void) {\n\t\treturn registerEvent(this.scrollParent, scroll, onScroll);\n\t}\n\n\t// subscribes Container and returns a function to reverse the effect\n\tpublic subscribe(type: EventType, cb: (e: ContainerEvent) => void): () => void {\n\t\treturn this.dispatcher.addEventListener(type, cb);\n\t}\n\n\tpublic get size(): Container['dimensions'] {\n\t\treturn this.dimensions;\n\t}\n\n\tpublic destroy(): void {\n\t\tthis.cleanups.forEach(cleanup => cleanup());\n\t\tthis.cleanups = [];\n\t}\n}\n","const debounce = <F extends (...args: any) => ReturnType<F>>(func: F, wait: number) => {\n\tlet timeoutId = 0; // setTimeout returns positive integer, so 0 represents no call requested\n\n\tconst debounced = function (this: ThisParameterType<F>, ...args: Parameters<F>) {\n\t\tclearTimeout(timeoutId);\n\t\ttimeoutId = window.setTimeout(() => {\n\t\t\ttimeoutId = 0;\n\t\t\tfunc.apply(this, args);\n\t\t}, wait);\n\t};\n\n\tdebounced.cancel = function () {\n\t\tclearTimeout(timeoutId);\n\t\ttimeoutId = 0;\n\t};\n\n\treturn debounced as ((...args: Parameters<F>) => ReturnType<F>) & { cancel: () => void };\n};\nexport default debounce;\n","const SM = 'ScrollMagic';\nexport class ScrollMagicError extends Error {\n\tpublic readonly name = `${SM}Error`;\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t}\n}\nexport class ScrollMagicErrorInternal extends ScrollMagicError {\n\tconstructor(message: string) {\n\t\tsuper(`Internal Error: ${message}`);\n\t}\n}\nexport const failWith = (message: string): ScrollMagicError => {\n\treturn new ScrollMagicError(message);\n};\nexport const failWithInternal = (message: string): ScrollMagicErrorInternal => {\n\treturn new ScrollMagicErrorInternal(message);\n};\nexport const warn = (first: unknown, ...args: unknown[]): void => {\n\tconsole?.warn(`${SM} Warning: ${first}`, ...args);\n};\n","import { Container, ContainerEvent, ScrollParent } from './Container';\nimport { ScrollMagic } from './ScrollMagic';\nimport { failWithInternal } from './ScrollMagicError';\nimport { isUndefined } from './util/typeguards';\n\ntype EventCallback = (e: ContainerEvent) => void;\ntype CleanUpFunction = () => void;\n\nexport class ContainerProxy {\n\tprivate static cache = new Map<ScrollParent, [Container, Set<ScrollMagic>]>();\n\n\tprivate container?: Container;\n\tconstructor(private readonly scene: ScrollMagic) {}\n\tprivate unsubscribers = new Array<CleanUpFunction>();\n\n\tpublic attach(scrollParent: ScrollParent, onUpdate: EventCallback): void {\n\t\tif (!isUndefined(this.container)) {\n\t\t\tthis.detach();\n\t\t}\n\t\tlet cache = ContainerProxy.cache.get(scrollParent);\n\t\tif (isUndefined(cache)) {\n\t\t\tcache = [new Container(scrollParent), new Set()];\n\t\t\tContainerProxy.cache.set(scrollParent, cache);\n\t\t}\n\t\tconst [container, scenes] = cache;\n\t\tscenes.add(this.scene);\n\t\tthis.container = container;\n\t\tthis.unsubscribers = [container.subscribe('resize', onUpdate), container.subscribe('scroll', onUpdate)];\n\t}\n\n\tpublic detach(): void {\n\t\tif (isUndefined(this.container)) {\n\t\t\treturn;\n\t\t}\n\t\tconst { scrollParent } = this.container;\n\t\tconst cache = ContainerProxy.cache.get(scrollParent);\n\t\tif (isUndefined(cache)) {\n\t\t\tthrow failWithInternal('No cache info for scrollParent');\n\t\t}\n\t\tconst [container, scenes] = cache;\n\t\tscenes.delete(this.scene);\n\t\tthis.unsubscribers.forEach(unsubscribe => unsubscribe());\n\t\tthis.unsubscribers = [];\n\t\tif (scenes.size === 0) {\n\t\t\t// no more attached scenes\n\t\t\tcontainer.destroy();\n\t\t\tContainerProxy.cache.delete(scrollParent);\n\t\t}\n\t\tthis.container = undefined;\n\t}\n\n\tpublic get rect(): Container['size'] {\n\t\tif (isUndefined(this.container)) {\n\t\t\tthrow failWithInternal(`Can't get size when not attached to a container`);\n\t\t}\n\t\treturn this.container.size;\n\t}\n}\n","import throttleRaf from './util/throttleRaf';\n\ntype Command = () => void;\ntype Prerequisite = () => boolean;\n\n/**\n * Holds a list of commands and execute them in order.\n * If a command is added twice before executing, it will stay in the order position as before.\n * Caveats:\n * - can't override commands with existing precondition\n */\n\nexport class ExecutionQueue {\n\tprotected readonly commands = new Map<Command, Prerequisite | null>(); // in js: remembers the original insertion order\n\tpublic execute(): void {\n\t\tthis.commands.forEach((prerequisite, command) => {\n\t\t\tif (false === prerequisite?.()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcommand();\n\t\t});\n\t\tthis.commands.clear();\n\t}\n\tpublic add(command: Command, prerequisite?: Prerequisite): void {\n\t\tconst existing = this.commands.get(command);\n\t\tif (null === existing) {\n\t\t\t// we can only go from has prerequisite to no prerequisite (get less strict)\n\t\t\treturn;\n\t\t}\n\t\tthis.commands.set(command, prerequisite ?? null);\n\t}\n\tpublic remove(command: Command): boolean {\n\t\treturn this.commands.delete(command);\n\t}\n\tpublic clear(): void {\n\t\tthis.commands.clear();\n\t}\n}\n\nexport class ThrottledExecutionQueue extends ExecutionQueue {\n\tprotected executeThrottled = throttleRaf(this.execute.bind(this));\n\t// adds a command to the queue and schedules it for execution\n\tpublic schedule(command: Command, prerequisite?: Prerequisite): void {\n\t\tthis.add(command, prerequisite);\n\t\tthis.executeThrottled();\n\t}\n\t// exedcutes the whole queue immediately\n\tpublic moveUp(): void {\n\t\tthis.executeThrottled.cancel();\n\t\tthis.execute();\n\t}\n\tpublic clear(): void {\n\t\tthis.executeThrottled.cancel();\n\t\tsuper.clear();\n\t}\n}\n","type SameProperties<T extends { [K in keyof T]: unknown }, R extends { [K in keyof T]: unknown }> = R;\ntype ExtendProperty<T extends { [K in keyof T]: unknown }, K extends keyof T, E> = Omit<T, K> & { [X in K]: T[X] | E };\ntype ModifyProperty<T extends { [K in keyof T]: unknown }, K extends keyof T, E> = Omit<T, K> & { [X in K]: E };\ntype UnitString = `${number}px` | `${number}%`;\ntype CenterShorthand = 'center';\ntype CssSelector = string;\n\n// takes the width or height height of an element and returns the value that is used for position calculations\nexport type PixelConverterElement = (elementSize: number) => number;\nexport type PixelConverterScrollParent = (scrollParentSize: number) => number;\n\nexport type Public = {\n\telement: Element | CssSelector | null;\n\tscrollParent: Window | Document | Element | CssSelector;\n\tvertical: boolean;\n\ttriggerStart: number | UnitString | CenterShorthand | PixelConverterScrollParent | null;\n\ttriggerEnd: number | UnitString | CenterShorthand | PixelConverterScrollParent | null;\n\telementStart: number | UnitString | CenterShorthand | PixelConverterElement;\n\telementEnd: number | UnitString | CenterShorthand | PixelConverterElement;\n};\n\n// basically a normalized version of the options\nexport type Private = SameProperties<\n\tPublic,\n\t{\n\t\telement: HTMLElement | SVGElement;\n\t\tscrollParent: Window | HTMLElement;\n\t\tvertical: boolean;\n\t\ttriggerStart: PixelConverterScrollParent;\n\t\ttriggerEnd: PixelConverterScrollParent;\n\t\telementStart: PixelConverterElement;\n\t\telementEnd: PixelConverterElement;\n\t}\n>;\n\n// values that can be null after processing and need to be inferred, if still null\nexport type PrivateUninferred = ExtendProperty<Private, 'triggerStart' | 'triggerEnd' | 'element', null>;\n// PixelConverters are executed and their values returned during computation\nexport type PrivateComputed = ModifyProperty<\n\tPrivate,\n\t'triggerStart' | 'triggerEnd' | 'elementStart' | 'elementEnd',\n\tnumber\n>;\n\n// default options\nexport const defaults: Public = {\n\telement: null,\n\tscrollParent: window,\n\tvertical: true,\n\ttriggerStart: null,\n\ttriggerEnd: null,\n\telementStart: 0,\n\telementEnd: 0,\n};\n\n// applied during fallback inference. if triggerStart or triggerEnd is null this will apply default if element is present and fallback otherwise\nexport const inferredTriggers: Record<string, PixelConverterElement> = {\n\tdefault: (scrollParentSize: number) => scrollParentSize, // default 100%, starts at bottom, ends at top\n\tfallback: () => 0, // if no element is supplied, it will fall back to the first child of scroll parent (usually the body), so it starts at the top and ends at the bottom\n};\n","const verticalProps = {\n\tstart: 'top',\n\tend: 'bottom',\n\tsize: 'height',\n\tclientSize: 'clientHeight',\n\tscrollSize: 'scrollHeight',\n} as const;\nconst horizontalProps = {\n\tstart: 'left',\n\tend: 'right',\n\tsize: 'width',\n\tclientSize: 'clientWidth',\n\tscrollSize: 'scrollWidth',\n} as const;\n\ntype VerticalProps = typeof verticalProps;\ntype HorizontalProps = typeof horizontalProps;\ntype Props = keyof VerticalProps & keyof HorizontalProps;\ntype SourceProps = VerticalProps[Props] | HorizontalProps[Props];\ntype RectInfo = Record<SourceProps, number>;\n\ntype MatchType<T, P, K extends keyof T & keyof P> = T[K] extends P[K] ? T[K] : undefined;\n\n/**\n * Returns the relevant property names depending on vertical or horizontal orientation.\n * @param vertical scrolldirection (true = vertical)\n */\nexport const pickRelevantProps = (vertical: boolean): VerticalProps | HorizontalProps =>\n\tvertical ? verticalProps : horizontalProps;\n/**\n * Returns the relevant boundary values depending on vertical or horizontal orientation.\n * I.E. top or left value => start, width / height => size.\n * @param obj Object to tretrieve the values from\n * @param vertical scrolldirection (true = vertical)\n */\nexport const pickRelevantValues = <T extends Partial<RectInfo>, V extends boolean>(\n\tvertical: V,\n\tobj: T\n\t// the idea with the return type is to make sure each property has the correct type based on the object that is passed in.\n\t// i.e. if both top and left exist -> number, if only top exists -> number | undefined, if neither exist -> undefined.\n): { [X in Props]: MatchType<T, RectInfo, VerticalProps[X]> | MatchType<T, RectInfo, HorizontalProps[X]> } =>\n\tObject.entries(pickRelevantProps(vertical)).reduce((res, [key, value]) => {\n\t\treturn {\n\t\t\t...res,\n\t\t\t[key]: obj[value],\n\t\t};\n\t}, {} as { [X in Props]: MatchType<T, RectInfo, VerticalProps[X]> | MatchType<T, RectInfo, HorizontalProps[X]> });\n","import { failWith } from 'scrollmagic/ScrollMagicError';\n\n// type to ensure there's an output processor for every input\nexport type PropertyProcessors<I extends { [X in keyof I]: unknown }, O extends { [X in keyof I]: unknown }> = {\n\t[X in keyof I]: (value: Required<I>[X]) => O[X];\n};\n\n/**\n * A function that can be used to validate the properties of an object based on predefined rules.\n * @param obj the object that should be processed\n * @param processors an object with matching keys, which defines how to normalize and or validate a property\n * @param getErrorMessage A function that returns the format for the error message, should normalize or check fail.\n * @returns the normalized and checked object\n */\n\nconst processProperties = <\n\tI extends { [X in keyof I]: any },\n\tP extends { [X in K]?: (value: Required<I>[X]) => any },\n\tO extends { [X in K]: P[X] extends (...args: any) => infer R ? R : I[X] },\n\tK extends keyof I\n>(\n\tobj: I,\n\tprocessors: P,\n\tgetErrorMessage: (value: unknown, prop: keyof I, reason?: string) => string = (value, prop, reason) =>\n\t\t`Invalid value ${value} for ${prop}. ${reason}`\n): O => {\n\treturn Object.keys(obj).reduce((result, key) => {\n\t\tconst prop = key as K;\n\t\tconst value = obj[prop];\n\t\tconst processor = processors[prop];\n\t\tlet processedValue: O[K];\n\t\ttry {\n\t\t\tprocessedValue = processor?.(value) ?? value;\n\t\t} catch (e) {\n\t\t\tthrow failWith(getErrorMessage(value, prop, e.message));\n\t\t}\n\t\tresult[prop] = processedValue;\n\t\treturn result;\n\t}, {} as O);\n};\nexport default processProperties;\n","import { failWith } from 'scrollmagic/ScrollMagicError';\n\nimport {\n\tisDocument,\n\tisHTMLElement,\n\tisNull,\n\tisNumber,\n\tisSVGElement,\n\tisString,\n\tisUndefined,\n\tisWindow,\n} from './typeguards';\n\ntype PixelConverter = (size: number) => number;\ntype UnitString = `${number}px` | `${number}%`;\n\nconst centerShorthand = 'center';\n\nexport const numberToPercString = (val: number): string => `${val * 100}%`;\n\nconst unitTupleToPixelConverter = ([value, unit]: [number, 'px' | '%']): PixelConverter => {\n\treturn unit === 'px' ? () => value : (size: number) => (value / 100) * size;\n};\n\nexport const unitStringToPixelConverter = (val: UnitString): PixelConverter => {\n\tconst match = val.match(/^([+-])?(\\d+|\\d*[.]\\d+)(%|px)$/);\n\tif (isNull(match)) {\n\t\tthrow failWith(`String value must be number with unit, i.e. 20px or 80% or '${centerShorthand}' (=50%)`);\n\t}\n\tconst [, sign, digits, unit] = match as [string, '+' | '-' | null, string, 'px' | '%'];\n\treturn unitTupleToPixelConverter([parseFloat(`${sign ?? ''}${digits}`), unit]);\n};\n\nexport const toPixelConverter = (\n\tval: number | UnitString | typeof centerShorthand | PixelConverter\n): PixelConverter => {\n\tif (isNumber(val)) {\n\t\treturn () => val;\n\t}\n\tif (isString(val)) {\n\t\tif (centerShorthand === val) {\n\t\t\tconst x = unitTupleToPixelConverter([50, '%']);\n\t\t\treturn x;\n\t\t}\n\t\treturn unitStringToPixelConverter(val);\n\t}\n\t// ok, probably passed in function, let's see if it works.\n\tlet returnsNumber: boolean;\n\ttry {\n\t\treturnsNumber = isNumber(val(1));\n\t} catch (e) {\n\t\tthrow failWith('Unsupported value type');\n\t}\n\tif (!returnsNumber) {\n\t\tthrow failWith('Function must return a number');\n\t}\n\treturn val;\n};\n\nexport const selectorToSingleElement = (selector: string): Element => {\n\tconst elem = document.querySelector(selector);\n\tif (isNull(elem)) {\n\t\tthrow failWith(`No element found for selector ${selector}`);\n\t}\n\treturn elem;\n};\n\nexport const toSvgOrHtmlElement = (reference: Element | string): HTMLElement | SVGElement => {\n\tconst elem = isString(reference) ? selectorToSingleElement(reference) : reference;\n\tconst { body } = window.document;\n\tif (!(isHTMLElement(elem) || isSVGElement(elem)) || !body.contains(elem)) {\n\t\tthrow failWith('Invalid element supplied');\n\t}\n\treturn elem;\n};\n\nexport const toValidScrollParent = (container: Window | Document | Element | string): Window | HTMLElement => {\n\tif (isWindow(container) || isDocument(container)) {\n\t\treturn window;\n\t}\n\tconst elem = toSvgOrHtmlElement(container);\n\tif (isSVGElement(elem)) {\n\t\tthrow failWith(`Can't use SVG as scrollParent`);\n\t}\n\treturn elem;\n};\n\n// returns null if null is passed in or returns the return value of the function that's passed in.\nexport const nullPassThrough = <F extends (val: any) => any>(\n\tfunc: F\n): ((val: Parameters<F>[0] | null) => ReturnType<F> | null) => (val: Parameters<F>[0] | null) =>\n\tisNull(val) ? val : func(val);\n\n// checks if a value is null and returns it, if it is not.\n// if it is, it runs a function to recover a value\nexport const toNonNullable = <T extends unknown>(val: T, recover: () => NonNullable<T>): NonNullable<T> =>\n\tisNull(val) || isUndefined(val) ? recover() : (val as NonNullable<T>);\n\nexport const toBoolean = (val: unknown): boolean => !!val;\n","import {\n\tPixelConverterScrollParent,\n\tPrivate,\n\tPrivateComputed,\n\tPrivateUninferred,\n\tPublic,\n\tinferredTriggers,\n\tdefaults as optionDefaults,\n} from './Options';\nimport { failWith, warn } from './ScrollMagicError';\nimport getDimensions from './util/getDimensions';\nimport { pickRelevantValues } from './util/pickRelevantInfo';\nimport processProperties, { PropertyProcessors } from './util/processProperties';\nimport { sanitizeProperties } from './util/sanitizeProperties';\nimport {\n\tnullPassThrough,\n\ttoBoolean,\n\ttoNonNullable,\n\ttoPixelConverter,\n\ttoSvgOrHtmlElement,\n\ttoValidScrollParent,\n} from './util/transformers';\nimport { isHTMLElement, isNull, isSVGElement, isWindow } from './util/typeguards';\n\nconst transformers: PropertyProcessors<Public, PrivateUninferred> = {\n\telement: nullPassThrough(toSvgOrHtmlElement),\n\tscrollParent: toValidScrollParent,\n\tvertical: toBoolean,\n\ttriggerStart: nullPassThrough(toPixelConverter),\n\ttriggerEnd: nullPassThrough(toPixelConverter),\n\telementStart: toPixelConverter,\n\telementEnd: toPixelConverter,\n};\n\n// removes unknown properties from supplied options\nexport const sanitize = <T extends Partial<Public>>(options: T): T => sanitizeProperties(options, optionDefaults);\n\n// converts all public values to their corresponding private value, leaving null values untoched\nconst transform = (options: Partial<Public>): Partial<PrivateUninferred> => processProperties(options, transformers);\n\n// processes remaining null values\nconst infer = (options: PrivateUninferred): Private => {\n\tconst { scrollParent, element } = options;\n\n\tconst inferElement = (elem: HTMLElement | SVGElement | null) =>\n\t\ttoNonNullable(elem, () => {\n\t\t\tconst elem = isWindow(scrollParent) ? document.body : scrollParent.firstElementChild;\n\t\t\tif (isNull(elem) || !(isHTMLElement(elem) || isSVGElement(elem))) {\n\t\t\t\tthrow failWith(`Could not autodetect element, as scrollParent has no valid children.`);\n\t\t\t}\n\t\t\treturn elem;\n\t\t});\n\n\tconst inferTrigger = (val: PixelConverterScrollParent | null) =>\n\t\ttoNonNullable(val, () => (isNull(element) ? inferredTriggers.fallback : inferredTriggers.default));\n\n\treturn processProperties(options, {\n\t\telement: inferElement,\n\t\ttriggerStart: inferTrigger,\n\t\ttriggerEnd: inferTrigger,\n\t});\n};\n\n// checks if the options the user entered actually make sense\nconst check = (options: Private): void => {\n\tconst { triggerStart, triggerEnd, elementStart, elementEnd, vertical, scrollParent } = options;\n\tconst { size: elementSize } = getElementSize(options);\n\tconst { clientSize: containerSize } = pickRelevantValues(vertical, getDimensions(scrollParent));\n\n\tconst elementDistance = elementSize - elementStart(elementSize) - elementEnd(elementSize);\n\tconst trackDistance = -(containerSize - triggerStart(containerSize) - triggerEnd(containerSize));\n\n\tconst total = elementDistance + trackDistance;\n\tif (total < 0) {\n\t\twarn(\n\t\t\t'Detected no overlap with the configured track options. This means ScrollMagic will not trigger unless this changes later on (i.e. due to resizes).',\n\t\t\tcompute(options)\n\t\t);\n\t}\n};\n\nexport const compute = (options: Private): PrivateComputed => {\n\tconst { triggerStart, triggerEnd, elementStart, elementEnd } = options;\n\tconst { size: elementSize } = getElementSize(options);\n\treturn {\n\t\t...options,\n\t\ttriggerStart: triggerStart(elementSize),\n\t\ttriggerEnd: triggerEnd(elementSize),\n\t\telementStart: elementStart(elementSize),\n\t\telementEnd: elementEnd(elementSize),\n\t};\n};\n\nexport const process = <T extends Partial<Public>>(\n\tnewOptions: T,\n\toldOptions: Private\n): { sanitized: T; processed: Private } => {\n\tconst sanitized = sanitize(newOptions);\n\tconst normalized = transform(sanitized);\n\tconst processed = infer({ ...oldOptions, ...normalized });\n\tcheck(processed); // finally sanity check\n\treturn { sanitized, processed };\n};\n\n// helpers\nconst getElementSize = ({ vertical, element }: Pick<Private, 'vertical' | 'element'>) =>\n\tpickRelevantValues(vertical, element.getBoundingClientRect());\n","import { warn } from 'scrollmagic/ScrollMagicError';\n\nexport const sanitizeProperties = <T extends Record<string, any>>(\n\tobj: T,\n\tdefaults: Record<string, any>,\n\tonUnknown = (propertyName: string) => {\n\t\twarn(`Unknown property ${propertyName} will be disregarded`);\n\t}\n): T =>\n\tObject.entries(obj).reduce((res, [key, value]) => {\n\t\tif (key in defaults === false) {\n\t\t\tonUnknown?.(key);\n\t\t\treturn res;\n\t\t}\n\t\tres[key as keyof T] = value;\n\t\treturn res;\n\t}, {} as T);\n","import { isWindow } from './typeguards';\n\nconst scrollTop = (container: Window | Element): number =>\n\tisWindow(container) ? window.pageYOffset : container.scrollTop;\n\nconst scrollLeft = (container: Window | Element): number =>\n\tisWindow(container) ? window.pageXOffset : container.scrollLeft;\n\nconst getScrollPos = (container: Window | Element): { left: number; top: number } => ({\n\tleft: scrollLeft(container),\n\ttop: scrollTop(container),\n});\nexport default getScrollPos;\n","const fromEntries = <T extends { [key: string]: any }>(obj: T, [key, value]: [string, any]) => ({\n\t...obj,\n\t[key]: value,\n});\n// checks an object against a reference object and returns a new object containing only differences in direct descendents (one way!)\nconst pickDifferencesFlat = <T extends Record<string, any>>(part: Partial<T>, full: T): Partial<T> =>\n\tObject.entries(part)\n\t\t.filter(([key, value]) => value !== full[key])\n\t\t.reduce(fromEntries, {});\nexport default pickDifferencesFlat;\n","export const roundToDecimals = (val: number, decimals: number): number => parseFloat(val.toFixed(decimals));\n","import pickDifferencesFlat from './util/pickDifferencesFlat';\nimport { isUndefined } from './util/typeguards';\n\ntype Margin = {\n\ttop: string;\n\tright: string;\n\tbottom: string;\n\tleft: string;\n};\n\ninterface Options {\n\troot?: Element | null; // null is window\n\tmargin?: Margin;\n}\n\ntype ObserverCallback = (isIntersecting: boolean, target: Element) => void;\n\n// this ensures the order in the object doesn't matter\nconst marginObjToString = ({ top, right, bottom, left }: Margin) => [top, right, bottom, left].join(' ');\n\nconst none = '0px';\n\nexport default class ViewportObserver {\n\tprivate observerEnter?: IntersectionObserver;\n\tprivate observerLeave?: IntersectionObserver;\n\tprivate options: Required<Options> = {\n\t\troot: null,\n\t\tmargin: { top: none, right: none, bottom: none, left: none },\n\t};\n\tprivate observedElements = new Map<Element, [boolean | undefined, boolean | undefined]>();\n\tconstructor(private callback: ObserverCallback, options?: Options) {\n\t\tif (isUndefined(options)) {\n\t\t\treturn; // nothing will happen, until modify is called.\n\t\t}\n\t\tthis.options = {\n\t\t\t...this.options,\n\t\t\t...options,\n\t\t};\n\t}\n\tprivate observerCallback(entries: IntersectionObserverEntry[], observer: IntersectionObserver) {\n\t\tentries.forEach(({ target, isIntersecting }) => {\n\t\t\tlet [hitEnter, hitLeave] = this.observedElements.get(target) ?? [];\n\t\t\tconst prevState = hitEnter && hitLeave;\n\t\t\tif (observer === this.observerEnter) {\n\t\t\t\thitEnter = isIntersecting;\n\t\t\t} else {\n\t\t\t\thitLeave = isIntersecting;\n\t\t\t}\n\t\t\tthis.observedElements.set(target, [hitEnter, hitLeave]);\n\t\t\tconst newState = hitEnter && hitLeave;\n\t\t\tif (isUndefined(newState) || prevState === newState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.callback(newState, target);\n\t\t});\n\t}\n\tprivate createObserver(rootMargin: string) {\n\t\tconst root = this.options.root;\n\t\tconst observer = new IntersectionObserver(this.observerCallback.bind(this), { root, rootMargin });\n\t\t[...this.observedElements.keys()].forEach(elem => observer.observe(elem));\n\t\treturn observer;\n\t}\n\tprivate rebuildObserver() {\n\t\tthis.observerEnter?.disconnect();\n\t\tthis.observerLeave?.disconnect();\n\t\tconst { margin } = this.options;\n\t\tconst maxDimension = (val: string) => `${Math.max(0, parseFloat(val))}%`;\n\n\t\t// TODO: check what happens, if the opposite value still overlaps (due to offset / height ?)\n\t\t// TODO! I know now: if effective duration exceeds available observer height it fails... -> BUG! -> FIX...\n\t\tconst marginEnter = { ...margin, top: maxDimension(margin.top) };\n\t\tconst marginLeave = { ...margin, bottom: maxDimension(margin.bottom) };\n\n\t\tthis.observerEnter = this.createObserver(marginObjToString(marginEnter));\n\t\tthis.observerLeave = this.createObserver(marginObjToString(marginLeave));\n\t}\n\tprivate optionsChanged({ root, margin }: Options) {\n\t\tif (!isUndefined(root) && root !== this.options.root) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!isUndefined(margin)) {\n\t\t\treturn Object.keys(pickDifferencesFlat(margin, this.options.margin)).length > 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic modify(options: Options): ViewportObserver {\n\t\tif (!this.optionsChanged(options)) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.options = {\n\t\t\t...this.options,\n\t\t\t...options,\n\t\t};\n\t\tthis.rebuildObserver();\n\t\treturn this;\n\t}\n\tpublic observe(elem: Element): ViewportObserver {\n\t\tif (!this.observedElements.has(elem)) {\n\t\t\tthis.observedElements.set(elem, [undefined, undefined]);\n\t\t\tthis.observerEnter?.observe(elem);\n\t\t\tthis.observerLeave?.observe(elem);\n\t\t}\n\t\treturn this;\n\t}\n\tpublic unobserve(elem: Element): ViewportObserver {\n\t\tif (this.observedElements.has(elem)) {\n\t\t\tthis.observedElements.delete(elem);\n\t\t\tthis.observerEnter?.unobserve(elem);\n\t\t\tthis.observerLeave?.unobserve(elem);\n\t\t}\n\t\treturn this;\n\t}\n\tpublic disconnect(): void {\n\t\tthis.observedElements.clear();\n\t\tthis.observerEnter?.disconnect();\n\t\tthis.observerLeave?.disconnect();\n\t}\n}\n","import { ContainerEvent } from './Container';\nimport { ContainerProxy } from './ContainerProxy';\nimport EventDispatcher from './EventDispatcher';\nimport { ThrottledExecutionQueue } from './ExecutionQueue';\nimport * as Options from './Options';\nimport {\n\tcompute as computeOptions,\n\tprocess as processOptions,\n\tsanitize as sanitizeOptions,\n} from './Options.processors';\nimport ScrollMagicEvent, { ScrollMagicEventType } from './ScrollMagicEvent';\nimport getScrollPos from './util/getScrollPos';\nimport pickDifferencesFlat from './util/pickDifferencesFlat';\nimport { pickRelevantProps, pickRelevantValues } from './util/pickRelevantInfo';\nimport { roundToDecimals } from './util/roundToDecimals';\nimport throttleRaf from './util/throttleRaf';\nimport { numberToPercString } from './util/transformers';\nimport { isUndefined, isWindow } from './util/typeguards';\nimport ViewportObserver from './ViewportObserver';\n\nexport { Public as ScrollMagicOptions } from './Options';\n\n// used for listeners to allow the value to be passed in either from the enum or as a string literal\ntype EventTypeEnumOrUnion = ScrollMagicEventType | `${ScrollMagicEventType}`;\nexport class ScrollMagic {\n\tpublic readonly name = 'ScrollMagic';\n\n\tprivate readonly dispatcher = new EventDispatcher();\n\tprivate readonly container = new ContainerProxy(this);\n\tprivate readonly resizeObserver = new ResizeObserver(throttleRaf(this.onElementResize.bind(this)));\n\tprivate readonly viewportObserver = new ViewportObserver(this.onIntersectionChange.bind(this));\n\tprivate readonly executionQueue = new ThrottledExecutionQueue();\n\tprivate readonly boundMethods = {\n\t\t// these are set to get permanent references for the throttled execution queue\n\t\tupdateProgress: this.updateProgress.bind(this),\n\t\tupdateViewportObserver: this.updateViewportObserver.bind(this),\n\t\tupdateTriggerBounds: this.updateElementBoundsCache.bind(this),\n\t} as const;\n\n\t// all below options should only ever be changed by a dedicated method\n\t// update function MUST NOT call any other functions, with the exceptions of modify\n\tprivate optionsPublic: Options.Public = ScrollMagic.defaultOptionsPublic;\n\tprivate optionsPrivate!: Options.Private; // set in modify in constructor\n\tprivate elementBoundsCache: { start: number; offsetStart: number; offsetEnd: number; size: number } = {\n\t\tstart: 0, // position relative to viewport\n\t\toffsetStart: 0, // offset relative to top/left of element\n\t\toffsetEnd: 0, // offset relative to bottom/right of element\n\t\tsize: 0, // actual size of element\n\t};\n\tprivate currentProgress = 0;\n\tprivate active?: boolean; // scene active state\n\n\t// TODO! BUGFIX scrolling too fast breaks it (use keyboard to go to top / bottom of page)\n\t// TODO: Don't update triggerBoundsCache in updateProgress, but add it to the scheduling\n\t// TODO: Execution Queue: Make sure items are always executed in the expected order\n\t// TODO: properly react to mobile headers resizing\n\t// TODO: build plugin interface\n\t// TODO: consider what should actually be private and what protected.\n\t// TODO: Maybe only include internal errors for development? process.env...\n\tconstructor(options: Partial<Options.Public> = {}) {\n\t\tconst initOptions: Options.Public = {\n\t\t\t...ScrollMagic.defaultOptionsPublic,\n\t\t\t...options,\n\t\t};\n\t\tthis.modify(initOptions);\n\t}\n\n\tprivate triggerEvent(type: ScrollMagicEventType, deltaProgress: number) {\n\t\tif (deltaProgress === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.dispatcher.dispatchEvent(new ScrollMagicEvent(type, deltaProgress > 0, this));\n\t}\n\n\tpublic modify(options: Partial<Options.Public>): ScrollMagic {\n\t\tconst { sanitized, processed } = processOptions(options, this.optionsPrivate);\n\n\t\tthis.optionsPublic = { ...this.optionsPublic, ...sanitized };\n\n\t\tconst changed = isUndefined(this.optionsPrivate) // internal options not set on first run, so all changed\n\t\t\t? processed\n\t\t\t: pickDifferencesFlat(processed, this.optionsPrivate);\n\t\tconst changedOptions = Object.keys(changed) as Array<keyof Options.Private>;\n\n\t\tif (changedOptions.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.optionsPrivate = processed;\n\n\t\tthis.onOptionChanges(changedOptions);\n\t\treturn this;\n\t}\n\n\tprivate getViewportMargin() {\n\t\tconst { triggerStart, triggerEnd, vertical } = this.optionsPrivate;\n\t\tconst { start: startProp, end: endProp } = pickRelevantProps(vertical);\n\t\tconst { start: oppositeStartProp, end: oppositeEndProp } = pickRelevantProps(!vertical);\n\t\tconst { clientSize: containerSize } = this.getContainerBounds();\n\t\tconst { scrollSize: oppositeScrollSize, clientSize: oppositeClientSize } = this.getContainerBounds(!vertical); // gets the opposites\n\t\tconst { offsetStart, offsetEnd } = this.elementBoundsCache; // from cache\n\n\t\tconst marginStart = containerSize - triggerStart(containerSize) + offsetStart;\n\t\tconst marginEnd = containerSize - triggerEnd(containerSize) + offsetEnd;\n\t\t/**\n\t\t ** confusingly IntersectionObserver (and thus ViewportObserver) treat margins in the opposite direction (negative means towards the center)\n\t\t ** so we'll have to flip the signs here.\n\t\t ** Additionally we convert it to percentages and round, as this means they are less likely to change, meaning less refreshes for the observer\n\t\t ** (as the observer internally compares old values to new ones)\n\t\t ** This way it won't have to internally create new IntersectionObservers, just because the scrollparent's size changes.\n\t\t */\n\t\tconst relMarginStart = -roundToDecimals(marginStart / containerSize, 5);\n\t\tconst relMarginEnd = -roundToDecimals(marginEnd / containerSize, 5);\n\n\t\t// adding available scrollspace in opposite direction, so element never moves out of trackable area, even when scrolling horizontally on a vertical scene\n\t\tconst scrollableOpposite = numberToPercString((oppositeScrollSize - oppositeClientSize) / oppositeClientSize);\n\t\treturn {\n\t\t\t// the start and end values are intentionally flipped here (start value defines end margin and vice versa)\n\t\t\t[endProp]: numberToPercString(relMarginStart),\n\t\t\t[startProp]: numberToPercString(relMarginEnd),\n\t\t\t[oppositeStartProp]: scrollableOpposite,\n\t\t\t[oppositeEndProp]: scrollableOpposite,\n\t\t} as Record<'top' | 'left' | 'bottom' | 'right', string>;\n\t}\n\n\tprivate getElementBounds() {\n\t\t// this should be called cautiously, getBoundingClientRect costs...\n\t\t// check variable initialisation for property description\n\t\tconst { elementStart, elementEnd, element, vertical } = this.optionsPrivate;\n\t\tconst { start, size: elementSize } = pickRelevantValues(vertical, element.getBoundingClientRect());\n\t\treturn {\n\t\t\tstart,\n\t\t\toffsetStart: elementStart(elementSize),\n\t\t\toffsetEnd: elementEnd(elementSize),\n\t\t\tsize: elementSize,\n\t\t};\n\t}\n\n\tprivate getContainerBounds(forceDirection?: boolean) {\n\t\treturn pickRelevantValues(forceDirection ?? this.optionsPrivate.vertical, this.container.rect); // these are already cached. fine to call as often as we like\n\t}\n\n\tprivate updateActive(nextActive: boolean | undefined) {\n\t\t// doesn't have to be a method, but I want to keep modifications obvious (only called from update... methods)\n\t\tthis.active = nextActive;\n\t}\n\n\tprivate updateElementBoundsCache() {\n\t\tthis.elementBoundsCache = this.getElementBounds();\n\t}\n\n\tprivate updateProgress() {\n\t\tif (false === this.active) {\n\t\t\t// also run if active is undefined (ViewportObserver not ready)\n\t\t\treturn;\n\t\t}\n\n\t\tconst { triggerStart, triggerEnd } = this.optionsPrivate;\n\t\t// todo cache on scroll!\n\t\tconst { offsetStart, offsetEnd, size: elementSize, start: elementPosition } = this.getElementBounds(); // get fresh\n\t\tconst { clientSize: containerSize } = this.getContainerBounds();\n\n\t\tconst containerOffsetStart = triggerStart(containerSize);\n\t\tconst containerOffsetEnd = triggerEnd(containerSize);\n\t\tconst start = elementPosition + offsetStart;\n\t\tconst elementDistance = elementSize - offsetStart - offsetEnd;\n\t\tconst trackDistance = -(containerSize - containerOffsetStart - containerOffsetEnd);\n\n\t\tconst passed = containerOffsetStart - start;\n\t\tconst total = elementDistance + trackDistance;\n\n\t\tif (total < 0) {\n\t\t\t// no overlap of track and scroll distance\n\t\t\treturn;\n\t\t}\n\n\t\tconst previousProgress = this.currentProgress;\n\t\tconst nextProgress = Math.min(Math.max(passed / total, 0), 1); // when leaving, it will overshoot, this normalises to 0 / 1\n\t\tconst deltaProgress = nextProgress - previousProgress;\n\n\t\tthis.currentProgress = nextProgress;\n\n\t\tif (previousProgress === 0 || previousProgress === 1) {\n\t\t\tthis.triggerEvent(ScrollMagicEventType.Enter, deltaProgress);\n\t\t}\n\t\tthis.triggerEvent(ScrollMagicEventType.Progress, deltaProgress);\n\t\tif (nextProgress === 0 || nextProgress === 1) {\n\t\t\tthis.triggerEvent(ScrollMagicEventType.Leave, deltaProgress);\n\t\t}\n\t}\n\n\tprivate updateViewportObserver(): void {\n\t\tconst { scrollParent } = this.optionsPrivate;\n\t\tconst observerOptions = {\n\t\t\tmargin: this.getViewportMargin(),\n\t\t\troot: isWindow(scrollParent) ? null : scrollParent,\n\t\t};\n\t\tthis.viewportObserver.modify(observerOptions);\n\t}\n\n\tprivate onOptionChanges(changes: Array<keyof Options.Private>) {\n\t\tconst isChanged = changes.includes.bind(changes);\n\t\tconst sizeChanged = isChanged('elementStart');\n\t\tconst offsetChanged = isChanged('elementEnd');\n\t\tconst elementChanged = isChanged('element');\n\t\tconst scrollParentChanged = isChanged('scrollParent');\n\n\t\tif (sizeChanged || offsetChanged || elementChanged) {\n\t\t\tthis.updateElementBoundsCache();\n\t\t\tif (elementChanged) {\n\t\t\t\tthis.updateActive(undefined);\n\t\t\t\tconst { element } = this.optionsPrivate;\n\t\t\t\tthis.viewportObserver.disconnect();\n\t\t\t\tthis.viewportObserver.observe(element);\n\t\t\t\tthis.resizeObserver.disconnect();\n\t\t\t\tthis.resizeObserver.observe(element);\n\t\t\t}\n\t\t}\n\t\tif (scrollParentChanged) {\n\t\t\tthis.updateActive(undefined);\n\t\t\tthis.container.attach(this.optionsPrivate.scrollParent, this.onContainerUpdate.bind(this)); // container updates are already throttled\n\t\t}\n\t\t// if the options change we always have to refresh the viewport observer, regardless which one it is...\n\t\tthis.updateViewportObserver();\n\t}\n\n\tprivate onElementResize() {\n\t\tconst { executionQueue, boundMethods, elementBoundsCache } = this;\n\t\tconst { offsetStart: startPrevious, offsetEnd: endPrevious } = elementBoundsCache;\n\t\texecutionQueue.schedule(boundMethods.updateTriggerBounds);\n\t\texecutionQueue.schedule(\n\t\t\tboundMethods.updateViewportObserver,\n\t\t\t// compare to current values => only execute, if changed during scheduled update above\n\t\t\t() => startPrevious !== elementBoundsCache.offsetStart || endPrevious !== elementBoundsCache.offsetEnd\n\t\t);\n\t\texecutionQueue.schedule(this.boundMethods.updateProgress);\n\t}\n\n\tprivate onContainerUpdate(e: ContainerEvent) {\n\t\tconst { executionQueue, boundMethods } = this;\n\t\tif ('resize' === e.type) {\n\t\t\texecutionQueue.schedule(boundMethods.updateViewportObserver);\n\t\t}\n\t\texecutionQueue.schedule(boundMethods.updateProgress);\n\t}\n\n\tprivate onIntersectionChange(intersecting: boolean, target: Element) {\n\t\t// the check below should always be true, as we only ever observe one element, but you can never be too sure, I guess...\n\t\tif (target === this.optionsPrivate.element) {\n\t\t\tthis.executionQueue.schedule(this.boundMethods.updateProgress);\n\t\t\tif (!intersecting) {\n\t\t\t\t// update immediately, if leaving and change active state after.\n\t\t\t\tthis.executionQueue.moveUp();\n\t\t\t}\n\t\t\tthis.updateActive(intersecting);\n\t\t}\n\t}\n\n\t// getter/setter public\n\tpublic set element(element: Options.Public['element']) {\n\t\tthis.modify({ element });\n\t}\n\tpublic get element(): Options.Public['element'] {\n\t\treturn this.optionsPublic.element;\n\t}\n\tpublic set scrollParent(scrollParent: Options.Public['scrollParent']) {\n\t\tthis.modify({ scrollParent });\n\t}\n\tpublic get scrollParent(): Options.Public['scrollParent'] {\n\t\treturn this.optionsPublic.scrollParent;\n\t}\n\tpublic set vertical(vertical: Options.Public['vertical']) {\n\t\tthis.modify({ vertical });\n\t}\n\tpublic get vertical(): Options.Public['vertical'] {\n\t\treturn this.optionsPublic.vertical;\n\t}\n\tpublic set triggerStart(triggerStart: Options.Public['triggerStart']) {\n\t\tthis.modify({ triggerStart });\n\t}\n\tpublic get triggerStart(): Options.Public['triggerStart'] {\n\t\treturn this.optionsPublic.triggerStart;\n\t}\n\tpublic set triggerEnd(triggerEnd: Options.Public['triggerEnd']) {\n\t\tthis.modify({ triggerEnd });\n\t}\n\tpublic get triggerEnd(): Options.Public['triggerEnd'] {\n\t\treturn this.optionsPublic.triggerEnd;\n\t}\n\tpublic set elementStart(elementStart: Options.Public['elementStart']) {\n\t\tthis.modify({ elementStart });\n\t}\n\tpublic get elementStart(): Options.Public['elementStart'] {\n\t\treturn this.optionsPublic.elementStart;\n\t}\n\tpublic set elementEnd(elementEnd: Options.Public['elementEnd']) {\n\t\tthis.modify({ elementEnd });\n\t}\n\tpublic get elementEnd(): Options.Public['elementEnd'] {\n\t\treturn this.optionsPublic.elementEnd;\n\t}\n\n\t// not an option -> getter only\n\tpublic get progress(): number {\n\t\treturn this.currentProgress;\n\t}\n\tpublic get scrollOffset(): { start: number; end: number } {\n\t\tconst { scrollParent, triggerStart, triggerEnd, vertical } = this.optionsPrivate;\n\t\tconst { start: elementStart, offsetStart, offsetEnd, size: elementSize } = this.getElementBounds();\n\t\tconst { clientSize: containerSize } = this.getContainerBounds();\n\t\tconst { start: scrollOffset } = pickRelevantValues(vertical, getScrollPos(scrollParent));\n\t\tconst elemOffset = elementStart + scrollOffset;\n\t\treturn {\n\t\t\tstart: Math.floor(elemOffset + offsetStart - triggerStart(containerSize)),\n\t\t\tend: Math.ceil(elemOffset + elementSize + offsetEnd - triggerEnd(containerSize)),\n\t\t};\n\t}\n\tpublic get computedOptions(): Options.PrivateComputed {\n\t\treturn computeOptions(this.optionsPrivate);\n\t}\n\n\t// event listener\n\tpublic on(type: EventTypeEnumOrUnion, cb: (e: ScrollMagicEvent) => void): ScrollMagic {\n\t\tthis.dispatcher.addEventListener(type as ScrollMagicEventType, cb);\n\t\treturn this;\n\t}\n\tpublic off(type: EventTypeEnumOrUnion, cb: (e: ScrollMagicEvent) => void): ScrollMagic {\n\t\tthis.dispatcher.removeEventListener(type as ScrollMagicEventType, cb);\n\t\treturn this;\n\t}\n\t// same as on, but returns a function to reverse the effect (remove the listener).\n\tpublic subscribe(type: EventTypeEnumOrUnion, cb: (e: ScrollMagicEvent) => void): () => void {\n\t\treturn this.dispatcher.addEventListener(type as ScrollMagicEventType, cb);\n\t}\n\n\tpublic destroy(): void {\n\t\tthis.executionQueue.clear();\n\t\tthis.resizeObserver.disconnect();\n\t\tthis.viewportObserver.disconnect();\n\t\tthis.container.detach();\n\t}\n\n\t// static options/methods\n\n\tprivate static defaultOptionsPublic = Options.defaults;\n\t// get or change default options\n\tpublic static default(options: Partial<Options.Public> = {}): Options.Public {\n\t\tthis.defaultOptionsPublic = {\n\t\t\t...this.defaultOptionsPublic,\n\t\t\t...sanitizeOptions(options),\n\t\t};\n\t\treturn this.defaultOptionsPublic;\n\t}\n}\n"],"names":["ScrollMagicEventType","ScrollMagicEventScrollDirection","ScrollMagicEventLocation","isNumber","val","isString","isUndefined","undefined","isNull","isWindow","Window","isHTMLElement","HTMLElement","isSVGElement","SVGElement","this","Map","EventDispatcher","type","cb","list","callbacks","get","set","push","_this","removeEventListener","remaining","filter","registeredCallback","event","forEach","getDimensions","element","elem","document","documentElement","clientWidth","clientHeight","scrollHeight","scrollWidth","registerEvent","target","listener","options","addEventListener","bind","throttleRaf","func","requestId","scheduled","_i","args","requestAnimationFrame","apply","cancel","cancelAnimationFrame","scroll","resize","scrollParent","wait","timeoutId","debounced","throttledScroll","updateScrollPos","throttledResize","updateDimensions","clearTimeout","window","setTimeout","cleanups","subscribeScroll","subscribeResize","Container","dispatcher","dispatchEvent","ContainerEvent","dimensions","onResize","observer","ResizeObserver","observe","unobserve","onScroll","Object","cleanup","SM","message","_super","__extends","Error","ScrollMagicError","failWith","failWithInternal","ScrollMagicErrorInternal","warn","first","console","scene","ContainerProxy","onUpdate","container","detach","cache","Set","_a","__read","add","unsubscribers","subscribe","scenes","delete","unsubscribe","size","destroy","execute","ThrottledExecutionQueue","command","prerequisite","executeThrottled","clear","ExecutionQueue","commands","defaults","vertical","triggerStart","triggerEnd","elementStart","elementEnd","inferredTriggers","default","scrollParentSize","fallback","verticalProps","start","end","clientSize","scrollSize","horizontalProps","pickRelevantProps","pickRelevantValues","obj","entries","reduce","res","_c","key","value","processProperties","processors","getErrorMessage","prop","reason","keys","result","processedValue","processor","e","centerShorthand","numberToPercString","unitTupleToPixelConverter","_b","toPixelConverter","returnsNumber","match","sign","digits","unit","parseFloat","unitStringToPixelConverter","toSvgOrHtmlElement","reference","selector","querySelector","selectorToSingleElement","body","contains","nullPassThrough","toNonNullable","recover","transformers","Document","sanitize","onUnknown","propertyName","sanitizeProperties","optionDefaults","compute","elementSize","getElementSize","process","newOptions","oldOptions","sanitized","normalized","processed","inferTrigger","firstElementChild","infer","containerSize","check","getBoundingClientRect","movingForward","location","Progress","Inside","Enter","Leave","Start","End","direction","Forward","Reverse","scrollTop","pageYOffset","scrollLeft","pageXOffset","fromEntries","pickDifferencesFlat","part","full","roundToDecimals","decimals","toFixed","marginObjToString","join","none","callback","root","margin","top","right","bottom","left","ViewportObserver","isIntersecting","observedElements","hitEnter","hitLeave","prevState","observerEnter","newState","rootMargin","IntersectionObserver","observerCallback","__spreadArray","disconnect","observerLeave","maxDimension","Math","max","marginEnter","marginLeave","createObserver","length","optionsChanged","rebuildObserver","has","onElementResize","onIntersectionChange","updateProgress","updateViewportObserver","updateTriggerBounds","updateElementBoundsCache","ScrollMagic","defaultOptionsPublic","offsetStart","offsetEnd","initOptions","modify","deltaProgress","ScrollMagicEvent","processOptions","optionsPrivate","optionsPublic","changed","changedOptions","onOptionChanges","startProp","endProp","_d","oppositeStartProp","oppositeEndProp","getContainerBounds","_e","oppositeScrollSize","oppositeClientSize","_f","elementBoundsCache","marginStart","marginEnd","relMarginStart","relMarginEnd","scrollableOpposite","forceDirection","rect","nextActive","active","getElementBounds","elementPosition","containerOffsetStart","passed","total","previousProgress","currentProgress","nextProgress","min","triggerEvent","observerOptions","getViewportMargin","viewportObserver","changes","isChanged","includes","sizeChanged","offsetChanged","elementChanged","scrollParentChanged","updateActive","resizeObserver","attach","onContainerUpdate","executionQueue","boundMethods","startPrevious","endPrevious","schedule","intersecting","moveUp","elemOffset","floor","ceil","computeOptions","sanitizeOptions","Options.defaults"],"mappings":"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"}