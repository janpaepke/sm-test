import { ContainerEvent } from './Container';
import * as Options from './Options';
import ScrollMagicEvent, { ScrollMagicEventType } from './ScrollMagicEvent';
export { Public as ScrollMagicOptions } from './Options';
declare type EventTypeEnumOrUnion = ScrollMagicEventType | `${ScrollMagicEventType}`;
declare type ElementBounds = {
    start: number;
    size: number;
    offsetStart: number;
    offsetEnd: number;
    trackSize: number;
};
declare type ContainerBounds = {
    clientSize: number;
    offsetStart: number;
    offsetEnd: number;
    trackSize: number;
    scrollSize: number;
};
export declare class ScrollMagic {
    readonly name = "ScrollMagic";
    private readonly dispatcher;
    private readonly container;
    private readonly resizeObserver;
    private readonly viewportObserver;
    private readonly executionQueue;
    private readonly update;
    protected optionsPublic: Options.Public;
    protected optionsPrivate: Options.Private;
    protected elementBoundsCache: ElementBounds;
    protected containerBoundsCache: ContainerBounds;
    protected currentProgress: number;
    protected intersecting?: boolean;
    constructor(options?: Partial<Options.Public>);
    protected getViewportMargin(): {
        top: string;
        left: string;
        right: string;
        bottom: string;
    };
    protected getTrackSize(): number;
    protected updateIntersectingState(nextIntersecting: boolean | undefined): void;
    protected updateElementBoundsCache(): void;
    protected updateContainerBoundsCache(): void;
    protected updateProgress(): void;
    protected updateViewportObserver(): void;
    protected onOptionChanges(changes: Array<keyof Options.Private>): void;
    protected onElementResize(): void;
    protected onContainerUpdate(e: ContainerEvent): void;
    protected onIntersectionChange(intersecting: boolean, target: Element): void;
    protected triggerEvent(type: ScrollMagicEventType, forward: boolean): void;
    modify(options: Partial<Options.Public>): ScrollMagic;
    set element(element: Options.Public['element']);
    get element(): Options.Public['element'];
    set scrollParent(scrollParent: Options.Public['scrollParent']);
    get scrollParent(): Options.Public['scrollParent'];
    set vertical(vertical: Options.Public['vertical']);
    get vertical(): Options.Public['vertical'];
    set triggerStart(triggerStart: Options.Public['triggerStart']);
    get triggerStart(): Options.Public['triggerStart'];
    set triggerEnd(triggerEnd: Options.Public['triggerEnd']);
    get triggerEnd(): Options.Public['triggerEnd'];
    set elementStart(elementStart: Options.Public['elementStart']);
    get elementStart(): Options.Public['elementStart'];
    set elementEnd(elementEnd: Options.Public['elementEnd']);
    get elementEnd(): Options.Public['elementEnd'];
    get progress(): number;
    get scrollOffset(): {
        start: number;
        end: number;
    };
    get computedOptions(): Options.PrivateComputed;
    on(type: EventTypeEnumOrUnion, cb: (e: ScrollMagicEvent) => void): ScrollMagic;
    off(type: EventTypeEnumOrUnion, cb: (e: ScrollMagicEvent) => void): ScrollMagic;
    subscribe(type: EventTypeEnumOrUnion, cb: (e: ScrollMagicEvent) => void): () => void;
    destroy(): void;
    protected static defaultOptionsPublic: Options.Public;
    static default(options?: Partial<Options.Public>): Options.Public;
}
//# sourceMappingURL=ScrollMagic.d.ts.map